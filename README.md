# 八数码问题

在一个**3×3**的棋盘中，存在**1~8**和**空白**共**9种**格子。给定一种状态，**只允许移动空白格**，应该通过何种路径达到目标状态呢？

![](https://cdn.jsdelivr.net/gh/bipy/CDN/repo/8-Digit-Problem/source/1.png)
![](https://cdn.jsdelivr.net/gh/bipy/CDN/repo/8-Digit-Problem/source/2.png)

# 解决思路

以初始状态为起点进行搜索，应用三种搜索算法：BFS, DFS, A\*

判断目标状态是否可达：逆序和奇偶性相同即可达

将每种状态看作一个节点，可以使用盲目搜索算法进行遍历，找到目标状态为止。由于状态空间的庞大（指数级），需要对状态进行查重筛检，这就使得算法的效率不尽人意，因此引入了启发式搜索的A\*算法。A\*算法使用一个人为定义的估值函数来估算每种状态的“距离”，从而使得不同状态之间的优劣得以区分，把无权图遍历问题转化为了有权图的最短路径问题，搜索效率得到了极大的提升。

由此看来，A\*算法最重要的部分便是估值算法的设计。对于八数码问题，经典的两种估值算法分别为：

1. 不在正确位置的数字个数
2. 每个数字到其正确位置的距离的和，称为**曼哈顿距离**

曼哈顿距离显然比不在位个数包含更多信息，因此针对本问题我选择了曼哈顿距离作为估值函数。

但是估值终究是估值，A*算法通过距离估值可以少走弯路，尽力而为地找到一个优解，但很可能并不是最优解。



详细讨论请见[启发式搜索：A*算法与八数码问题探究](https://blog.zhengrh.com/post/8digit/)

# 实验记录

运行环境：G++ 8.2.1 x64

## BFS

| 实验样本    | 深度 | 遍历次数 | 耗时/s |
| ----------- | ---- | -------- | ------ |
| "134-85726" | 7    | 166      | 0.03   |
| "5674-8321" | 30   | 181358   | 0.557  |
| "-75168324" | 28   | 179983   | 0.628  |
| "32841-567" | 29   | 180492   | 0.532  |
| "32-418567" | 30   | 181228   | 0.535  |



## DFS

**设置最大递归深度为32**

| 实验样本    | 理论深度 | 寻找深度 | 遍历次数 | 耗时/s |
| ----------- | -------- | -------- | -------- | ------ |
| "134-85726" | 7        | 31       | 203512   | 0.431  |
| "5674-8321" | 30       | 32       | 188739   | 0.352  |
| "-75168324" | 28       | 32       | 1867331  | 2.386  |
| "32841-567" | 29       | 31       | 871753   | 1.213  |
| "32-418567" | 30       | 32       | 1015214  | 1.511  |



## A*

| 实验样本    | 理论深度 | 寻找深度 | 遍历次数 | 耗时/s |
| ----------- | -------- | -------- | -------- | ------ |
| "134-85726" | 7        | 7        | 9        | 0.051  |
| "5674-8321" | 30       | 30       | 5691     | 0.189  |
| "-75168324" | 28       | 28       | 8152     | 0.194  |
| "32841-567" | 29       | 29       | 12747    | 0.219  |
| "32-418567" | 30       | 30       | 18765    | 0.296  |
